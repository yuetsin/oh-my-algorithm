# Lecture 5

> 递归。

## 递归

### 引论

如果要处理的数据结构是「自相似」的（最典型的，Tree 结构），那么就递归就有了用武之地。

最简单的递归形式就是把一个问题分成多个子问题，其中每个问题或者是平凡的，或者是和原问题结构相似但更加简单。

合理的递归算法必须能够结束。如果把整个调用链画成一棵树的形式，那么每个叶子节点都对应一个平凡问题的解决。

在分割问题时，问题有没有变得更简单是重要的。

一个典型的问题是形式上递归地调用自身，但是问题却没有简化。这样的递归通常以栈溢出告终。

### 定义

直接或间接地调用自身的算法称为递归算法。

用函数自身给出定义的函数称为递归函数。

通常的递归思路始于分治：反复应用分治手段，使得子问题和原问题类型一致但是规模缩小，最后达到平凡状态从而容易求解。

### 实例

#### 阶乘和数列

两个最常见的递归实例就是「阶乘」和「斐波那契数列」。

```java
public static long factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```



```java
public static int fibonacci(int n)
{
    if (n <= 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

实际上，这两个算法都不是很好。

「阶乘」用例的递归链过于直接，可以简单用 `for` 循环改写。而「Fibonacci」则存在大量的重复计算，效率过低。

#### 圆盘问题

一个更加经典的例子是「Hanoi 塔」问题。

> 一般译作「汉诺塔」而非「河内塔」。

设 $a$、$b$、$c$ 是 3 个塔座。开始时，在塔座 $a$ 上有一叠共 $n$ 个圆盘，这些圆盘自下而上，由大到小地叠在一起。

各圆盘从小到大编号为 $1, 2, \dots, n$。现要求将塔座 $a$ 上的这一叠 圆盘移到塔座 $b$ 上，并仍按同样顺序叠置。

在移动圆盘时需要遵守以下移动规则：

* 每次只能移动 1 个圆盘；

* 任何时刻都不允许将较大的圆盘压在较小的圆盘之上；

* 在满足移动规则 1 和 2 的前提下，可将圆盘移至 $a$、$b$、$c$ 中任一塔座上。

实际上，每一次操作都可以由一组二元数表记。例如 `move(a, b)` 代表将 $a$ 柱顶部的那个圆盘移动到 $b$ 上。

那么，一般化的 `hanoi` 函数，即将任意（$n$）个圆盘从一柱移动到另一柱的方法可以这么写：

```java
public static void hanoi(int n, int a, int b, int c) {
    if (n > 0) {
        hanoi(n - 1, a, c, b);
        move(a, b);
        hanoi(n - 1, c, b, a);
    }
}
```

> 首先把靠上的 $n - 1$ 个圆盘移动到临时柱 $c$ 上；然后将最底部的（也就是最大的）圆盘移动到位，最後把临时柱上的 $n - 1$ 个盘移动上来即可。
>
> 因此，移动叠加的 $n$ 个圆盘可以划分为 1 次简单移动 + 2 次 $n - 1$ 个叠加圆盘的移动。
>
> 不难看出这种移动的耗时是 $O(2^n)$ 的。所以古代传说中的 `64` 个圆盘的汉诺塔，真的是一辈子都移动不完的（$2^{64}$ 太大了）。

