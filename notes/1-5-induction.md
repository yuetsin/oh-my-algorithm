# Lecture 5

> 递归。

## 递归

### 引论

如果要处理的数据结构是「自相似」的（最典型的，Tree 结构），那么就递归就有了用武之地。

最简单的递归形式就是把一个问题分成多个子问题，其中每个问题或者是平凡的，或者是和原问题结构相似但更加简单。

合理的递归算法必须能够结束。如果把整个调用链画成一棵树的形式，那么每个叶子节点都对应一个平凡问题的解决。

在分割问题时，问题有没有变得更简单是重要的。

一个典型的问题是形式上递归地调用自身，但是问题却没有简化。这样的递归通常以栈溢出告终。

### 定义

直接或间接地调用自身的算法称为递归算法。

用函数自身给出定义的函数称为递归函数。

通常的递归思路始于分治：反复应用分治手段，使得子问题和原问题类型一致但是规模缩小，最后达到平凡状态从而容易求解。

### 实例

#### 阶乘和数列

两个最常见的递归实例就是「阶乘」和「斐波那契数列」。

```java
public static long factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```



```java
public static int fibonacci(int n)
{
    if (n <= 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

实际上，这两个算法都不是很好。

「阶乘」用例的递归链过于直接，可以简单用 `for` 循环改写。而「Fibonacci」则存在大量的重复计算，效率过低。

#### 圆盘问题

一个更加经典的例子是「Hanoi 塔」问题。

> 一般译作「汉诺塔」而非「河内塔」。

设 $a$、$b$、$c$ 是 3 个塔座。开始时，在塔座 $a$ 上有一叠共 $n$ 个圆盘，这些圆盘自下而上，由大到小地叠在一起。

各圆盘从小到大编号为 $1, 2, \dots, n$。现要求将塔座 $a$ 上的这一叠 圆盘移到塔座 $b$ 上，并仍按同样顺序叠置。

在移动圆盘时需要遵守以下移动规则：

* 每次只能移动 1 个圆盘；

* 任何时刻都不允许将较大的圆盘压在较小的圆盘之上；

* 在满足移动规则 1 和 2 的前提下，可将圆盘移至 $a$、$b$、$c$ 中任一塔座上。

实际上，每一次操作都可以由一组二元数表记。例如 `move(a, b)` 代表将 $a$ 柱顶部的那个圆盘移动到 $b$ 上。

那么，一般化的 `hanoi` 函数，即将任意（$n$）个圆盘从一柱移动到另一柱的方法可以这么写：

```java
public static void hanoi(int n, int a, int b, int c) {
    if (n > 0) {
        hanoi(n - 1, a, c, b);
        move(a, b);
        hanoi(n - 1, c, b, a);
    }
}
```

> 首先把靠上的 $n - 1$ 个圆盘移动到临时柱 $c$ 上；然后将最底部的（也就是最大的）圆盘移动到位，最後把临时柱上的 $n - 1$ 个盘移动上来即可。
>
> 因此，移动叠加的 $n$ 个圆盘可以划分为 1 次简单移动 + 2 次 $n - 1$ 个叠加圆盘的移动。
>
> 不难看出这种移动的耗时是 $O(2^n)$ 的。所以古代传说中的 `64` 个圆盘的汉诺塔，真的是一辈子都移动不完的（$2^{64}$ 太大了）。

### 权衡

首先…

* 结构清晰，可读性强。容易用数学归纳法来证明算法的正确性。
* 为设计算法、 调试程序带来很大方便。

但是…

* 递归算法的运行效率低
* 耗费的计算时间、占用的存储空间（主要是因为需要维护 Stack）都比非递归算法多。

## 归纳法

正名为「Mathematical Induction」，即数学归纳法。

### 证明方法

为了证明命题 $F(n)$ 对任意正整数 $n$ 均成立，我们采用下面的流程方法：

* 证明 $F(1)$ 平凡情况成立。
* 证明 $F(k)$ 对任意 $k \ge 1$ 成立时，有 $F(k + 1)$ 成立。

注意在使用数学归纳法时，一定要提前说明，并遵循这一形式。

### 共通之处

和递归一样。他们能够解决的问题有如下特征：

* 解决问题的一个小规模事例是可能的（平凡情况）
* 每一个问题的解答都可以由更小规模问题的解答构造出来（归纳步骤）

大概最难的部分就是「如何简化问题」。

对于递归来说，最难的部分是如何将 $k$ 问题归化到若干个 $k - 1$ 问题。

对于归纳法来说，最难的部分是如何根据 $k - 1$ 结论的成立推出 $k$ 结论的成立。

## 例子

### 多项式求值

#### 问题

给出一组 $a_0, a_1, a_2, \dots, a_n$ 以及 $x$。高效地求出
$$
a_0 + a_1 x + a_2 x^2 + \dots + a_n x^n
$$
的值。

> 实际上这在第一课习题（1.37）里出现过。就是秦九韶算法嘛。
>
> 翻译成英文叫做 Horner 算法。

#### 解答

考虑将原式子分解成
$$
(\dots ((a_n x + a_{n - 1})x + a_{n - 2})x + \dots + a_1)x + a_0
$$
的形式。我们记
$$
F_k(x) = a_k + a_{k + 1} x + \dots + a_n x^{n - k}
$$
那么就有
$$
F_{k}(x) = x F_{k - 1}(x) + a_{n - k}
$$
这可以很显然地解释为何秦九韶算法只需要 $n$ 次乘法和 $n$ 次加法就能解决问题。

又由于问题的分解流是一条直线，所以可以简单地用循环来代替递归。

```pseudocode
// comments: Algorithm 5.6 HORNER

p <- an
for j <- 1 to n 
	p <- xp + an - j 
end for
return p
```

### 生成全排列

#### 问题

给出 $n$ 个互异的数字，显然他们有 $A_n^n$，即 $n!$ 种不同的排列方式。

设这 $n$ 个数字就是 `list(range(n))`，设计算法生成全部的排列。

#### 解答

看起来简单实际上难。

这里，有两种典型的实现方式。

##### 解法一

```python
#!/usr/bin/env python3

array = []
array_len = -1


def generate_perm(n):
    global array
    global array_len
    array = list(range(1, n + 1))
    array_len = n
    perm_helper(0)


def perm_helper(m: int):
    global array
    global array_len
    if m == array_len - 1:
        print(array)
    else:
        for j in range(m, array_len):
            array[j], array[m] = array[m], array[j]
            perm_helper(m + 1)
            array[j], array[m] = array[m], array[j]


if __name__ == '__main__':
    generate_perm(4)
```

第一种：前後交换法。每一个 `perm_helper(m)` 都会递归地调用 `perm_helper(m + 1)` `n - m` 次。每次调用时，还会将 `array[m]` 和 `array[j]` 做交换。

考虑：既然 `perm_helper(m + 1)` 会将数组中位于 `m + 1 ~ n` 部分的所有排列都遍历一遍，那么为了将其拓展到 `perm_helper(m)` 的情况，就仅仅需要让 `array[m]` 元素和後面的 `n - m` 个元素依次调换一下位置，每次都再跑一次 `perm_helper(m + 1)`，就可以了。

> 注意不要遗漏了「不做交换」的情况。正是因此，`for j in range(m, array_len)` 要从 `m` 开始遍历。

##### 解法二

```python
#!/usr/bin/env python3

array = []
array_len = -1


def generate_perm(n):
    global array
    global array_len
    array = [0] * n
    array_len = n
    perm_helper(n)


def perm_helper(m: int):
    global array
    global array_len
    if m == 0:
        print(array)
    else:
        for j in range(array_len):
            if array[j] == 0:
                array[j] = m
                perm_helper(m - 1)
                array[j] = 0


if __name__ == '__main__':
    generate_perm(4)
```

这种方法将 `array` 初始化成 $n$ 个全 0 数组；然后从大到小地把一些数字往里面填写。

标记为 `0` 的位置代表其可以放置另一个数字。采用这种「递归塞数字」，类似于 DFS 的方法就可以填满所有的可能性了。

### 社会名流问题

#### 问题

给定一个 $n$ 个人的集合；定义一个被所有人知道但却不知道任何一个其他人的人，被定义为社会名流。

给出一组人以及它们之间认识的关系；提供接口 `judge(a, b)`，在常数时间内判断 `a` 是否认识 `b`。

判断其中是否存在「社会名流」。

#### 解答

##### 分析

显然，一个集合中至多有一个社会名流。因为如果存在两个，那么他们之间无论谁认识谁或是谁不认识谁，都违背了「社会名流」的定义。

我们将「A 认识 B」抽象成在有向图中，由节点 A 指向节点 B 的一条边。

那么「社会名流」就相当于一个入度为 $n - 1$ 且出度为 $0$ 的节点。

##### 笨蛋解答

对每一个节点 `i`，做 `2(n - 1)` 次判断其是否满足「社会名流」的条件。

这样的时间复杂度就是 $O(n^2)$。太差了…

#### 聪明解答

确认一个人是「社会名流」非常困难（这个条件很强）；但排除一个人不是「社会名流」却很简单。

只要 `A` 认识某一个人，或者是有一个人不认识 `A`，那么 `A` 就一定不是「社会名流」。

因此我们在做笨蛋遍历的过程中，每遍历一条边都可以排除一个不是「社会名流」的人。

* 假如 `A` 认识 `B`，那么 `A` 一定不是社会名流
* 假如 `A` 不认识 `B`，那么 `A` 一定不是社会名流

因此，对于 $n$ 个人之间的关系网，我们只需要对还没有排除嫌疑的人逐次进行 $n - 1$ 次「认识与否」检查，即可排除掉 $n - 1$ 个不是「社会名流的人」；最後，花 $O(n)$ 的时间检查最後这个人是否是社会名流，即可得到结果。

总的时间复杂度可以降低到 $O(n)$ 级别。

### 寻找布尔什维克

#### 问题

在 $n$ 个可能重复的元素中，寻找出其中是否有出现次数超过（不包括等于）半数的元素。

#### 解答

##### 大笨蛋解法

遍历 $n$ 个元素，并且对每一个出现元素进行计数（每次的复杂度都是 $O(n)$）。

对于这种问题，写出 $O(n^2)$ 的人无法饶恕。

##### 人类解法

遍历一次，并且用 $O(n)$ 的空间对每个元素出现的频率计数。

然后，遍历一次计数器，观察其中是否有过半者。

这里的时间复杂度是 $O(n)$，空间复杂度也是 $O(n)$。

##### 聪明解法

用 $O(n)$ 的时间复杂度找中位数。

##### 小聪明解法

每次从原数组中删除两个不相同的元素；到剩下最後 2 个或 1 个的时候，就可以判断了。

> 实际上，假如你用的编程语言对于数组删除实现不好的话，这可能比上面的解法都慢。

# 作业

* 5.8
* 5.17(a)
* 5.19(a)
* 5.20
* 5.21
* 5.28
* 5.33

